import { FileSystemRepository } from './file-system.repo';
import {
  FileSystemItem,
  CreateFileSystemItemDTO,
  UpdateFileSystemItemDTO,
  TreeNode,
} from './types';
import { Result, ok, err } from '@/lib/utils';
export interface FileSystemService {
  getAllItems(projectID: string): Promise<Result<FileSystemItem[], string>>;
  getItem(id: string): Promise<Result<FileSystemItem | null, string>>;
  getFolderContents(
    folderId: string | undefined,
  ): Promise<Result<FileSystemItem[], string>>;

  createItem(
    input: CreateFileSystemItemDTO,
  ): Promise<Result<FileSystemItem, string>>;
  updateItem(
    id: string,
    updates: UpdateFileSystemItemDTO,
  ): Promise<Result<FileSystemItem, string>>;
  deleteItem(id: string): Promise<Result<null, string>>;

  moveItem(
    id: string,
    newParentId: string | undefined,
    order: number,
  ): Promise<Result<FileSystemItem, string>>;
  searchItems(query: string): Promise<Result<FileSystemItem[], string>>;
  buildFolderTree(items: FileSystemItem[]): TreeNode[];
}

export function createFileSystemService(
  userId: string,
  projectId: string,
  repo: FileSystemRepository,
): FileSystemService {
  async function validateCreateInput(
    input: CreateFileSystemItemDTO,
  ): Promise<Result<FileSystemItem, string>> {
    if (!input.name || input.name.trim() === '') {
      return err('Item name is required.');
    }
    if (input.type !== 'file' && input.type !== 'folder') {
      return err('Invalid item type.');
    }
    // create a new object to ensure immutability
    let newItem: FileSystemItem = {
      id: '', // to be generated by repo
      userId,
      projectId,
      order: 0, // to be set by repo
      name: input.name.trim(),
      type: input.type,
      parentId: input.parentId,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    if (newItem.type === 'file') {
      newItem = {
        ...newItem,
        content: input.content || '',
        size: input.content
          ? new TextEncoder().encode(input.content).length
          : 0,
      };
    }
    if (input.type === 'folder') {
    }
    return ok(newItem);
  }
  async function validateUpdateInput(
    updates: UpdateFileSystemItemDTO,
  ): Promise<Result<UpdateFileSystemItemDTO, string>> {
    if (updates.name !== undefined && updates.name.trim() === '') {
      return err('Item name cannot be empty');
    }
    // trim name if provided
    if (updates.name !== undefined) {
      updates.name = updates.name.trim();
    }
    return ok(updates);
  }
  async function checkCircularReference(
    itemId: string,
    targetParentId: string,
    repo: FileSystemRepository,
    userId: string,
  ): Promise<boolean> {
    // PSEUDOCODE:
    // if no target -> cannot be circular
    // if target === item -> circular
    // keep a visited set to guard against existing bad cycles in data
    // loop:
    //   fetch node = await repo.findById(currentId, userId)
    //   if repo returns error -> throw / bubble error (or return true to be safe)
    //   if node is null -> break (reached a parent outside store)
    //   if node.parentId is undefined -> break (reached root)
    //   if node.parentId === itemId -> return true (moving under descendant)
    //   if visited already contains node.parentId -> return true (existing cycle)
    //   add node.parentId to visited
    //   currentId = node.parentId
    // end loop
    // return false (no circular reference found)
  }

  return {
    // Gets all items (folders + files) for the this project
    async getAllItems(): Promise<Result<FileSystemItem[], string>> {
      const filesResult = await repo.findAll(userId, projectId);
      if (!filesResult.ok) {
        return err(filesResult.error);
      }
      return ok(filesResult.data);
    },
    // Gets a single item by ID cross-project
    async getItem(id: string): Promise<Result<FileSystemItem | null, string>> {
      if (!id) {
        return err('Invalid item ID');
      }
      const itemResult = await repo.findById(id, userId);
      if (!itemResult.ok) {
        return err(itemResult.error);
      }

      return ok(itemResult.data);
    },
    async getFolderContents(
      parentId: string,
    ): Promise<Result<FileSystemItem[], string>> {
      // if the parentId is undefined, we are fetching root items
      if (parentId === undefined) {
        const rootItemsResult = await repo.findByParentId(parentId, userId);
        if (!rootItemsResult.ok) {
          return err(rootItemsResult.error);
        }
        return ok(rootItemsResult.data);
      }
      const contentsResult = await repo.findByParentId(parentId, userId);
      if (!contentsResult.ok) {
        return err(contentsResult.error);
      }
      return ok(contentsResult.data);
    },

    async createItem(
      input: CreateFileSystemItemDTO,
    ): Promise<Result<FileSystemItem, string>> {
      const newItem = await validateCreateInput(input);
      if (!newItem.ok) {
        return err(newItem.error);
      }
      // check if parent folder exists
      if (newItem.data.parentId) {
        const parentResult = await repo.findById(newItem.data.parentId, userId);
        if (!parentResult.ok) {
          return err('Parent folder does not exist or unauthorized');
        }
        if (parentResult.data && parentResult.data.type !== 'folder') {
          return err('Parent item is not a folder');
        }
      }
      const createdResult = await repo.create(newItem.data, userId);
      if (!createdResult.ok) {
        return err(createdResult.error);
      }
      return ok(createdResult.data);
    },
    async updateItem(
      id: string,
      updates: UpdateFileSystemItemDTO,
    ): Promise<Result<FileSystemItem, string>> {
      // validating updates
      const validUpdates = await validateUpdateInput(updates);
      if (!validUpdates.ok) {
        return err(validUpdates.error);
      }

      // check if item exists
      const existingItemResult = await repo.findById(id, userId);
      if (!existingItemResult.ok) {
        return err(existingItemResult.error);
      }

      if (existingItemResult.data === null) {
        return err(`Item with id ${id} not found`);
      }

      // check if user owns the item

      const updatedResult = await repo.update(id, userId, validUpdates.data);
      if (!updatedResult.ok) {
        return err(updatedResult.error);
      }
      return ok(updatedResult.data);
    },
    async deleteItem(id: string): Promise<Result<null, string>> {
      if (!id || id.trim() === '') {
        return err('Invalid item ID provided.');
      }

      // quick existence check (keeps current behavior for "not found" and auth errors)
      const rootResult = await repo.findById(id, userId);
      if (!rootResult.ok) {
        return err(rootResult.error);
      }
      if (rootResult.data === null) {
        return err(`Item with id ${id} not found`);
      }

      // iterative DFS to produce a POST-ORDER list of IDs (children before parent)
      const stack: Array<{ id: string; expanded: boolean }> = [{ id, expanded: false }];
      const visited = new Set<string>();
      const postOrderIds: string[] = [];

      while (stack.length > 0) {
        const node = stack.pop()!;
        const nodeId = node.id;

        if (!node.expanded) {
          // detect cycles: if we already expanded this id earlier in the path, a cycle exists
          if (visited.has(nodeId)) {
            return err(`Circular reference detected for item ${nodeId}`);
          }
          visited.add(nodeId);

          // push back as expanded so we add it to postOrder after children
          stack.push({ id: nodeId, expanded: true });

          // fetch the node to see if it's a folder and to get its children
          const itemRes = await repo.findById(nodeId, userId);
          if (!itemRes.ok) {
            return err(itemRes.error);
          }
          if (itemRes.data === null) {
            return err(`Item with id ${nodeId} not found`);
          }
          const item = itemRes.data;

          if (item.type === 'folder') {
            const childrenRes = await repo.findByParentId(nodeId, userId);
            if (!childrenRes.ok) {
              return err(childrenRes.error);
            }

            // deterministic order for deletion: sort by `order` (missing -> 0)
            const children = childrenRes.data.slice().sort(
              (a, b) => (typeof a.order === 'number' ? a.order : 0) - (typeof b.order === 'number' ? b.order : 0),
            );

            // push children onto stack so they'll be processed before the parent (LIFO)
            for (let i = children.length - 1; i >= 0; i--) {
              stack.push({ id: children[i].id, expanded: false });
            }
          }
        } else {
          // post-order time: children already handled
          postOrderIds.push(nodeId);
        }
      }

      // Now delete everything in one go via batchDelete (children-first ordering preserved)
      const batchRes = await repo.batchDelete(postOrderIds, userId);
      if (!batchRes.ok) {
        // Standardize nested-delete failure message for consistency with existing tests.
        // If you prefer to surface repo errors directly, return err(batchRes.error) instead.
        return err('One or more items could not be deleted due to an database error.');
      }

      return ok(null);
    }
,
    async moveItem(
      id: string,
      newParentId: string | undefined,
      order: number,
    ): Promise<Result<FileSystemItem, string>> {
      // Validations
      if (!id || id.trim() === '') {
        return err('Invalid item ID provided.');
      }
      if (newParentId !== undefined && newParentId.trim() === '') {
        return err('Invalid target parent ID provided.');
      }
      if (id === newParentId) {
        return err(
          'Cannot move item into itself. Please choose a different target location.',
        );
      }

      // check if item exists
      const existingItemResult = await repo.findById(id, userId);
      if (!existingItemResult.ok) {
        return err(existingItemResult.error);
      }
      if (existingItemResult.data === null) {
        return err(`Item with id ${id} not found`);
      }
      if (existingItemResult.data.parentId === newParentId) {
        // check if order is the same
        if (existingItemResult.data.order === order) {
          // do nothing, item is already where it needs to be
          return ok(existingItemResult.data);
        }
        // else, just update the order
        const updatedOrderResult = await repo.update(id, userId, {
          order,
        });
        if (!updatedOrderResult.ok) {
          return err(updatedOrderResult.error);
        }
        return ok(updatedOrderResult.data
        )
      }
      const itemToMove = existingItemResult.data;
      // handle if moving to root (newParentId undefined)
      if (newParentId === undefined) {
        // check for named item in root with same name
        const rootItemsResult = await repo.findByParentId(
          undefined,
          userId,
        );
        if (!rootItemsResult.ok) {
          return err(rootItemsResult.error);
        }
        const nameConflict = rootItemsResult.data.find(
          (item) =>
            item.name === itemToMove.name && item.id !== itemToMove.id,
        );
        // if name conflict, add (n) suffix
        // check for current suffixes
        if (nameConflict) {
          let suffixNumber = 1;
          let newName = `${itemToMove.name} (${suffixNumber})`;
          while (
            rootItemsResult.data.find(
              (item) =>
                item.name === newName && item.id !== itemToMove.id,
            )
          ) {
            suffixNumber += 1;
            newName = `${itemToMove.name} (${suffixNumber})`;
          }
          itemToMove.name = newName;
        }
        // perform move to root
        const movedRootResult = await repo.update(id, userId, {
          parentId: undefined,
          order,
          name: itemToMove.name,
        });
        if (!movedRootResult.ok) {
          return err(movedRootResult.error);
        }
        return ok(movedRootResult.data);
      }
      // check if target parent exists and is a folder
      const targetParentResult = await repo.findById(newParentId, userId);
      if (!targetParentResult.ok) {
        return err(targetParentResult.error);
      }
      if (targetParentResult.data === null) {
        return err('Target parent folder does not exist.');
      }
      if (targetParentResult.data.type !== 'folder') {
        return err('Target parent must be a folder.');
      }

      if (targetParentResult.data.userId !== userId){
        return err('Unauthorized to access target parent folder.');
      }
      if (targetParentResult.data.projectId !== projectId) {
        return err('Target parent folder does not belong to the same project.');
      }
      // check for circular reference
      const hasCircularRef = await checkCircularReference(
        id,
        newParentId,
        repo,
        userId,
      );
      if (hasCircularRef) {
        return err(
          'Cannot move item into one of its subfolders. Please choose a different target location.',
        );
      }
      // get contents of target folder to check for name conflicts
      const targetFolderContentsResult = await repo.findByParentId(
        newParentId,
        userId,
      );
      if (!targetFolderContentsResult.ok) {
        return err(targetFolderContentsResult.error);
      }
      const nameConflict = targetFolderContentsResult.data.find(
        (item) =>
          item.name === itemToMove.name && item.id !== itemToMove.id,
      );
      // if name conflict, add (n) suffix
      if (nameConflict) {
        let suffixNumber = 1;
        let newName = `${itemToMove.name} (${suffixNumber})`;
        while (
          targetFolderContentsResult.data.find(
            (item) =>
              item.name === newName && item.id !== itemToMove.id,
          )
        ) {
          suffixNumber += 1;
          newName = `${itemToMove.name} (${suffixNumber})`;
        }
        itemToMove.name = newName;
      }
      // perform move
      const movedResult = await repo.update(id, userId, {
        parentId: newParentId,
        order,
        name: itemToMove.name,
      });
      if (!movedResult.ok) {
        return err(movedResult.error);
      }
      return ok(movedResult.data);
    },
    async searchItems(
      query: string,
    ): Promise<Result<FileSystemItem[], string>> {
      if (!query || query.trim() === '') {
        return err('Search query cannot be empty.');
      }
      const searchResult = await repo.search(query.trim(), userId, projectId);
      if (!searchResult.ok) {
        return err(searchResult.error);
      }
      return ok(searchResult.data);
    },
    buildFolderTree(items: FileSystemItem[]): TreeNode[] {
      type NodeWithChildren = FileSystemItem & { children: TreeNode[] };
      const itemMap: Record<string, NodeWithChildren> = {};
      const roots: NodeWithChildren[] = [];

      // Initialize the map with children arrays
      for (const item of items) {
        itemMap[item.id] = { ...item, children: [] };
      }

      // Build the tree
      for (const item of items) {
        const node = itemMap[item.id];
        // If no parentId -> it's a root
        if (!item.parentId) {
          roots.push(node);
          continue;
        }

        // Guard against self-parenting
        if (item.parentId === item.id) {
          roots.push(node);
          continue;
        }

        const parent = itemMap[item.parentId];
        // If parent exists, attach as child; otherwise treat as root (orphaned)
        if (parent) {
          parent.children.push(node);
        } else {
          roots.push(node);
        }
      }

      // Helper to get numeric order (missing -> 0)
      const getOrder = (n: TreeNode) => (typeof n.order === 'number' ? n.order : 0);

      // Sort children recursively by order
      const sortRecursively = (node: NodeWithChildren) => {
        if (node.children && node.children.length > 0) {
          node.children.sort((a, b) => getOrder(a) - getOrder(b));
          for (const child of node.children) {
            sortRecursively(child as NodeWithChildren);
          }
        }
      };

      // Sort roots by order, then sort each subtree
      roots.sort((a, b) => getOrder(a) - getOrder(b));
      for (const r of roots) sortRecursively(r);

      return roots;
    }

,
  };
}
