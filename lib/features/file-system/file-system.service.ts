import { check } from 'prettier/standalone.js';
import { FileSystemRepository } from './file-system.repo';
import {
  FileSystemItem,
  CreateFileSystemItemDTO,
  UpdateFileSystemItemDTO,
  TreeNode,
} from './types';
import { Result, ok, err } from '@/lib/utils';
export interface FileSystemService {
  getAllItems(projectID: string): Promise<Result<FileSystemItem[], string>>;
  getItem(id: string): Promise<Result<FileSystemItem | null, string>>;
  getFolderContents(
    folderId: string | undefined,
  ): Promise<Result<FileSystemItem[], string>>;

  createItem(
    input: CreateFileSystemItemDTO,
  ): Promise<Result<FileSystemItem, string>>;
  updateItem(
    id: string,
    updates: UpdateFileSystemItemDTO,
  ): Promise<Result<FileSystemItem, string>>;
  deleteItem(id: string): Promise<Result<null, string>>;

  moveItem(
    id: string,
    newParentId: string | undefined,
    order: number,
  ): Promise<Result<FileSystemItem, string>>;
  searchItems(query: string): Promise<Result<FileSystemItem[], string>>;
  buildFolderTree(items: FileSystemItem[]): TreeNode[];
}

export function createFileSystemService(
  userId: string,
  projectId: string,
  repo: FileSystemRepository,
): FileSystemService {
  async function validateCreateInput(
    input: CreateFileSystemItemDTO,
  ): Promise<Result<FileSystemItem, string>> {
    if (!input.name || input.name.trim() === '') {
      return err('Item name is required.');
    }
    if (input.type !== 'file' && input.type !== 'folder') {
      return err('Invalid item type.');
    }
    // create a new object to ensure immutability
    let newItem: FileSystemItem = {
      id: '', // to be generated by repo
      userId,
      projectId,
      order: 0, // to be set by repo
      name: input.name.trim(),
      type: input.type,
      parentId: input.parentId,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    if (newItem.type === 'file') {
      newItem = {
        ...newItem,
        content: input.content || '',
        size: input.content
          ? new TextEncoder().encode(input.content).length
          : 0,
      };
    }
    if (input.type === 'folder') {
    }
    return ok(newItem);
  }
  async function validateUpdateInput(
    updates: UpdateFileSystemItemDTO,
  ): Promise<Result<UpdateFileSystemItemDTO, string>> {
    if (updates.name !== undefined && updates.name.trim() === '') {
      return err('Item name cannot be empty');
    }
    // trim name if provided
    if (updates.name !== undefined) {
      updates.name = updates.name.trim();
    }
    return ok(updates);
  }
  async function checkCircularReference(
    itemId: string,
    targetParentId: string,
    repo: FileSystemRepository,
    userId: string,
  ): Promise<boolean> {
    // 50/50 true or false if circular reference detected
    const randomCheck = Math.random() < 0.5;
    if (randomCheck) {
      return false;
    }
    return true;
  }
  return {
    // Gets all items (folders + files) for the this project
    async getAllItems(): Promise<Result<FileSystemItem[], string>> {
      const filesResult = await repo.findAll(userId, projectId);
      if (!filesResult.ok) {
        return err(filesResult.error);
      }
      return ok(filesResult.data);
    },
    // Gets a single item by ID cross-project
    async getItem(id: string): Promise<Result<FileSystemItem | null, string>> {
      if (!id) {
        return err('Invalid item ID');
      }
      const itemResult = await repo.findById(id, userId);
      if (!itemResult.ok) {
        return err(itemResult.error);
      }

      return ok(itemResult.data);
    },
    async getFolderContents(
      parentId: string,
    ): Promise<Result<FileSystemItem[], string>> {
      // if the parentId is undefined, we are fetching root items
      if (parentId === undefined) {
        const rootItemsResult = await repo.findByParentId(parentId, userId);
        if (!rootItemsResult.ok) {
          return err(rootItemsResult.error);
        }
        return ok(rootItemsResult.data);
      }
      const contentsResult = await repo.findByParentId(parentId, userId);
      if (!contentsResult.ok) {
        return err(contentsResult.error);
      }
      return ok(contentsResult.data);
    },

    async createItem(
      input: CreateFileSystemItemDTO,
    ): Promise<Result<FileSystemItem, string>> {
      const newItem = await validateCreateInput(input);
      if (!newItem.ok) {
        return err(newItem.error);
      }
      // check if parent folder exists
      if (newItem.data.parentId) {
        const parentResult = await repo.findById(newItem.data.parentId, userId);
        if (!parentResult.ok) {
          return err('Parent folder does not exist or unauthorized');
        }
        if (parentResult.data && parentResult.data.type !== 'folder') {
          return err('Parent item is not a folder');
        }
      }
      const createdResult = await repo.create(newItem.data, userId);
      if (!createdResult.ok) {
        return err(createdResult.error);
      }
      return ok(createdResult.data);
    },
    async updateItem(
      id: string,
      updates: UpdateFileSystemItemDTO,
    ): Promise<Result<FileSystemItem, string>> {
      // validating updates
      const validUpdates = await validateUpdateInput(updates);
      if (!validUpdates.ok) {
        return err(validUpdates.error);
      }

      // check if item exists
      const existingItemResult = await repo.findById(id, userId);
      if (!existingItemResult.ok) {
        return err(existingItemResult.error);
      }

      if (existingItemResult.data === null) {
        return err(`Item with id ${id} not found`);
      }

      // check if user owns the item

      const updatedResult = await repo.update(id, userId, validUpdates.data);
      if (!updatedResult.ok) {
        return err(updatedResult.error);
      }
      return ok(updatedResult.data);
    },
    async deleteItem(id: string): Promise<Result<null, string>> {
      if (!id || id.trim() === '') {
        return err('Invalid item ID provided.');
      }
      // check if item exists
      const existingItemResult = await repo.findById(id, userId);
      if (!existingItemResult.ok) {
        return err(existingItemResult.error);
      }
      if (existingItemResult.data === null) {
        return err(`Item with id ${id} not found`);
      }

      // if folder, get all children and delete them recursively
      if (existingItemResult.data.type === 'folder') {
        const childrenResult = await repo.findByParentId(id, userId);
        if (!childrenResult.ok) {
          return err(childrenResult.error);
        }
        if (childrenResult.data.length > 0) {
          for (const child of childrenResult.data) {
            const deleteChildResult = await this.deleteItem(child.id);
            if (!deleteChildResult.ok) {
              // Standardize the message when any nested deletion fails
              return err(
                'One or more items could not be deleted due to an database error.',
              );
            }
          }
        } else {
          // empty folder -> delete directly
          const deleteEmptyFolderResult = await repo.delete(id, userId);
          if (!deleteEmptyFolderResult.ok) {
            return err(
              'One or more items could not be deleted due to an database error.',
            );
          }
          return ok(null);
        }
      }

      const deleteResult = await repo.delete(id, userId);
      if (!deleteResult.ok) {
        return err(
          'Database failed to delete item',
        );
      }
      return ok(null);
    },
    async moveItem(
      id: string,
      newParentId: string | undefined,
      order: number,
    ): Promise<Result<FileSystemItem, string>> {
      // Validations
      if (!id || id.trim() === '') {
        return err('Invalid item ID provided.');
      }
      if (newParentId !== undefined && newParentId.trim() === '') {
        return err('Invalid target parent ID provided.');
      }
      if (id === newParentId) {
        return err(
          'Cannot move item into itself. Please choose a different target location.',
        );
      }

      // check if item exists
      const existingItemResult = await repo.findById(id, userId);
      if (!existingItemResult.ok) {
        return err(existingItemResult.error);
      }
      if (existingItemResult.data === null) {
        return err(`Item with id ${id} not found`);
      }
      // if parentID is undefined, move item to root at the end
      if(newParentId === undefined){
        const moveToRootResult = await repo.update(id, userId, { parentId: undefined, order: order });
      }
      // if parentID is defined, check if parent exists and is a folder
      // check for circular references
      // check for naming conflicts in target parent folder
      // proceed to move item to given position in target parent folder (or root) given order
      // NOTE: pinned items are always at the top, so order is among unpinned items only

      return err('Not implemented yet');
    },
    async searchItems(
      query: string,
    ): Promise<Result<FileSystemItem[], string>> {
      if (!query || query.trim() === '') {
        return err('Search query cannot be empty.');
      }
      const searchResult = await repo.search(query.trim(), userId, projectId);
      if (!searchResult.ok) {
        return err(searchResult.error);
      }
      return ok(searchResult.data);
    },
    buildFolderTree(items: FileSystemItem[]): TreeNode[] {
      type NodeWithChildren = FileSystemItem & { children: TreeNode[] };
      const itemMap: Record<string, NodeWithChildren> = {};
      const roots: NodeWithChildren[] = [];

      // Initialize the map with children arrays
      for (const item of items) {
        itemMap[item.id] = { ...item, children: [] };
      }

      // Build the tree
      for (const item of items) {
        const node = itemMap[item.id];
        // If no parentId -> it's a root
        if (!item.parentId) {
          roots.push(node);
          continue;
        }

        // Guard against self-parenting
        if (item.parentId === item.id) {
          roots.push(node);
          continue;
        }

        const parent = itemMap[item.parentId];
        // If parent exists, attach as child; otherwise treat as root (orphaned)
        if (parent) {
          parent.children.push(node);
        } else {
          roots.push(node);
        }
      }

      // Helper to get numeric order (missing -> 0)
      const getOrder = (n: TreeNode) => (typeof n.order === 'number' ? n.order : 0);

      // Sort children recursively by order
      const sortRecursively = (node: NodeWithChildren) => {
        if (node.children && node.children.length > 0) {
          node.children.sort((a, b) => getOrder(a) - getOrder(b));
          for (const child of node.children) {
            sortRecursively(child as NodeWithChildren);
          }
        }
      };

      // Sort roots by order, then sort each subtree
      roots.sort((a, b) => getOrder(a) - getOrder(b));
      for (const r of roots) sortRecursively(r);

      return roots;
    }

,
  };
}
